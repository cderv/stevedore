% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/docker_client.R
\name{docker_client}
\alias{docker_client}
\title{Create docker client}
\usage{
docker_client(..., api_version = NULL, host = NULL, cert_path = NULL,
  tls_verify = NULL, machine = NULL, http_client_type = NULL,
  data_frame = NULL, quiet = FALSE, ignore_environment = FALSE)
}
\arguments{
\item{...}{Reserved for future use.  Passing in any unrecognised
argument will throw an error.  Part of the role of this argument
is to force use of named arguments until the API is stabilised.}

\item{api_version}{Version of the API request from the api.
Options are \code{NULL} (the default) - use the package's
default version (currently
\Sexpr{stevedore:::DOCKER_API_VERSION_DEFAULT}), a version as a
string or \code{\link{numeric_version}} object (supported
between \Sexpr{stevedore:::DOCKER_API_VERSION_MIN} and
\Sexpr{stevedore:::DOCKER_API_VERSION_MAX}), or the string
\code{detect} which will use the highest version out of the
version reported by the api and
\Sexpr{stevedore:::DOCKER_API_VERSION_MAX}.  If the environment
variable \code{DOCKER_API_VERSION} is set then this will be used
as the version (this is the same behaviour as the command line
client).}

\item{host}{The URL for the docker daemon.  This can be a unix
socket (e.g., unix:///var/run/docker.sock) on macOS/Linux, a
named pipe (e.g., \code{npipe:////./pipe/docker_engine}) on
Windows, or an http or https url (e.g.,
\code{https://localhost:2376}).  If not given, we use the
environment variable \code{DOCKER_HOST}, falling back on the
default socket or named pipe (for macOS/unix and windows
respectively).}

\item{cert_path}{The path to a directory containing certificate
files.  If using an \code{https} url this is required.  If not
given, we use the environment variable \code{DOCKER_CERT_PATH}.
This is ignored without warning if used with a socket or named
pipe connection.}

\item{tls_verify}{Logical, indicating if TLS should be verified.
This is only used if using an https connction (i.e., host is a
tcp/http/https url and\code{cert_path} is given).  If not given,
we use the environment variable \code{DOCKER_TLS_VERIFY}.}

\item{machine}{Scalar character (if provided) indicating the name
of a "docker machine" instance to use.  If this is provided then
\code{docker-machine} must be installed and the machine must
exist and be running.  \code{stevedore} will run
\code{docker-machine env machine} to determine the environment
variables to contact this machine and use these values for
\code{host}, \code{cert_path} and \code{tls_verify} (silently
ignoring any provided values).  Carl Boettiger is working on a
\href{https://github.com/cboettig/dockermachine}{dockermachine}
package for R that would make managing docker machines from R
easier.  As an alternative to this option, one can set
docker-machine environment variables as described in
`docker-machine env` before running R and they would be picked
up as described above.}

\item{http_client_type}{HTTP client type to use.  The options are
(currently) "curl", which uses the \code{curl} package (works
over unix sockets and over TCP) and \code{httppipe} which works
over unix sockets and windows named pipes, using the Docker
SDK's pipe code via the \code{httppipe} package.  Not all
functionality is supported with the \code{httppipe} client.
This option may eventually be moved into the \code{...} argument
as is not intended for end-user use; it is primarily intended
for debugging in development (forcing the \code{httppipe} client
where the \code{curl} client would ordinarily be preferred).}

\item{data_frame}{Function, used to wrap data.frames returned.
This may make output easier to consume.  You might use
\code{tibble::as_tibble} to return a \code{tbl_df} or
\code{datatable::as.data.table} to return \code{data.table}
objects.  This will be applied to all data.frames \emph{after}
they are constructed, and so must take a single argument (the
newly constructed data.frame) and return a new object that is
largely compatible with data.frame.  Another use for this would
be to define a function \code{data_frame = function(x)
structure(x, class = c("foo", "data.frame"))} to set the class
of all returned data.frame objects to be "foo" as well and then
defining a custom S3 print method for "foo" that limited the
output.}

\item{quiet}{Suppress informational messages.}

\item{ignore_environment}{Logical, indicating if environment
variables (\code{DOCKER_HOST}, \code{DOCKER_CERT_PATH},
\code{DOCKER_TLS_VERIFY} and \code{DOCKER_API_VERSION}) should
be ignored (this has no effect if \code{machine} is specified).}
}
\description{
Create a docker client object, which allows you to interact with
docker from R.  The object has several \emph{methods} that allow
interaction with the docker daemon (for this object they are all
"system" commands) and \emph{collections}, which contains further
methods.  The client is structured similarly to the docker command
line client, such that \code{docker container create <args>} in
the command line becomes \code{docker$container$create(...)} in R
(if the client is called R).  You can also access a default client
by using \code{stevedore::docker} (see \code{\link{docker}}).
}
\details{
\Sexpr[results=rd,stage=render]{stevedore:::generate_help()}
}
\examples{
if (docker_available()) {
  # Create a new client object:
  client <- stevedore::docker_client()

  # Version information for your docker daemon:
  client$version()

  # General information about your daemon:
  client$info()

  # Most of the interesting methods are within the collections.
  # For example, to see a summary of running containers:
  client$container$list()

  # (see ?docker_container) for more information.
}
}
